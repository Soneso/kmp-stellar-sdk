// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * struct LedgerHeader
 * {
 *     uint32 ledgerVersion;    // the protocol version of the ledger
 *     Hash previousLedgerHash; // hash of the previous ledger header
 *     StellarValue scpValue;   // what consensus agreed to
 *     Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
 *     Hash bucketListHash;     // hash of the ledger state
 * 
 *     uint32 ledgerSeq; // sequence number of this ledger
 * 
 *     int64 totalCoins; // total number of stroops in existence.
 *                       // 10,000,000 stroops in 1 XLM
 * 
 *     int64 feePool;       // fees burned since last inflation run
 *     uint32 inflationSeq; // inflation sequence number
 * 
 *     uint64 idPool; // last used global ID, used for generating objects
 * 
 *     uint32 baseFee;     // base fee per operation in stroops
 *     uint32 baseReserve; // account base reserve in stroops
 * 
 *     uint32 maxTxSetSize; // maximum size a transaction set can be
 * 
 *     Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
 *                       // in time without walking the chain back ledger by ledger
 *                       // each slot contains the oldest ledger that is mod of
 *                       // either 50  5000  50000 or 500000 depending on index
 *                       // skipList[0] mod(50), skipList[1] mod(5000), etc
 * 
 *     // reserved for future use
 *     union switch (int v)
 *     {
 *     case 0:
 *         void;
 *     case 1:
 *         LedgerHeaderExtensionV1 v1;
 *     }
 *     ext;
 * };
 */
data class LedgerHeaderXdr(
  /** the protocol version of the ledger */
  val ledgerVersion: Uint32Xdr,
  /** hash of the previous ledger header */
  val previousLedgerHash: HashXdr,
  /** what consensus agreed to */
  val scpValue: StellarValueXdr,
  /** the TransactionResultSet that led to this ledger */
  val txSetResultHash: HashXdr,
  /** hash of the ledger state */
  val bucketListHash: HashXdr,
  /** sequence number of this ledger */
  val ledgerSeq: Uint32Xdr,
  /** total number of stroops in existence. */
  val totalCoins: Int64Xdr,
  /**
   * 10,000,000 stroops in 1 XLM
   * fees burned since last inflation run
   */
  val feePool: Int64Xdr,
  /** inflation sequence number */
  val inflationSeq: Uint32Xdr,
  /** last used global ID, used for generating objects */
  val idPool: Uint64Xdr,
  /** base fee per operation in stroops */
  val baseFee: Uint32Xdr,
  /** account base reserve in stroops */
  val baseReserve: Uint32Xdr,
  /** maximum size a transaction set can be */
  val maxTxSetSize: Uint32Xdr,
  val skipList: Array<HashXdr>,
  val ext: LedgerHeaderExtXdr
) {
  companion object {

    fun decode(reader: XdrReader): LedgerHeaderXdr {
      val ledgerVersion = Uint32Xdr.decode(reader)
      val previousLedgerHash = HashXdr.decode(reader)
      val scpValue = StellarValueXdr.decode(reader)
      val txSetResultHash = HashXdr.decode(reader)
      val bucketListHash = HashXdr.decode(reader)
      val ledgerSeq = Uint32Xdr.decode(reader)
      val totalCoins = Int64Xdr.decode(reader)
      val feePool = Int64Xdr.decode(reader)
      val inflationSeq = Uint32Xdr.decode(reader)
      val idPool = Uint64Xdr.decode(reader)
      val baseFee = Uint32Xdr.decode(reader)
      val baseReserve = Uint32Xdr.decode(reader)
      val maxTxSetSize = Uint32Xdr.decode(reader)
      val skipList = Array(4) { HashXdr.decode(reader) }
      val ext = LedgerHeaderExtXdr.decode(reader)
      return LedgerHeaderXdr(ledgerVersion, previousLedgerHash, scpValue, txSetResultHash, bucketListHash, ledgerSeq, totalCoins, feePool, inflationSeq, idPool, baseFee, baseReserve, maxTxSetSize, skipList, ext)
    }
  }

  fun encode(writer: XdrWriter) {
    ledgerVersion.encode(writer)
    previousLedgerHash.encode(writer)
    scpValue.encode(writer)
    txSetResultHash.encode(writer)
    bucketListHash.encode(writer)
    ledgerSeq.encode(writer)
    totalCoins.encode(writer)
    feePool.encode(writer)
    inflationSeq.encode(writer)
    idPool.encode(writer)
    baseFee.encode(writer)
    baseReserve.encode(writer)
    maxTxSetSize.encode(writer)
    skipList.forEach { item ->
      item.encode(writer)
    }
    ext.encode(writer)
  }
}
