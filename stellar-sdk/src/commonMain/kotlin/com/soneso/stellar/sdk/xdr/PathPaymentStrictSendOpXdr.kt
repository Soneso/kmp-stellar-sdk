// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * struct PathPaymentStrictSendOp
 * {
 *     Asset sendAsset;  // asset we pay with
 *     int64 sendAmount; // amount of sendAsset to send (excluding fees)
 * 
 *     MuxedAccount destination; // recipient of the payment
 *     Asset destAsset;          // what they end up with
 *     int64 destMin;            // the minimum amount of dest asset to
 *                               // be received
 *                               // The operation will fail if it can't be met
 * 
 *     Asset path<5>; // additional hops it must go through to get there
 * };
 */
data class PathPaymentStrictSendOpXdr(
  /** asset we pay with */
  val sendAsset: AssetXdr,
  /** amount of sendAsset to send (excluding fees) */
  val sendAmount: Int64Xdr,
  /** recipient of the payment */
  val destination: MuxedAccountXdr,
  /** what they end up with */
  val destAsset: AssetXdr,
  /** the minimum amount of dest asset to */
  val destMin: Int64Xdr,
  val path: List<AssetXdr>
) {
  companion object {

    fun decode(reader: XdrReader): PathPaymentStrictSendOpXdr {
      val sendAsset = AssetXdr.decode(reader)
      val sendAmount = Int64Xdr.decode(reader)
      val destination = MuxedAccountXdr.decode(reader)
      val destAsset = AssetXdr.decode(reader)
      val destMin = Int64Xdr.decode(reader)
      val path = List(reader.readInt()) { AssetXdr.decode(reader) }
      return PathPaymentStrictSendOpXdr(sendAsset, sendAmount, destination, destAsset, destMin, path)
    }
  }

  fun encode(writer: XdrWriter) {
    sendAsset.encode(writer)
    sendAmount.encode(writer)
    destination.encode(writer)
    destAsset.encode(writer)
    destMin.encode(writer)
    writer.writeInt(path.size)
    path.forEach { item ->
      item.encode(writer)
    }
  }
}
