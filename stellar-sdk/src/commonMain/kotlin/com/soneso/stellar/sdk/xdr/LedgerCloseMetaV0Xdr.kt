// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * struct LedgerCloseMetaV0
 * {
 *     LedgerHeaderHistoryEntry ledgerHeader;
 *     // NB: txSet is sorted in "Hash order"
 *     TransactionSet txSet;
 * 
 *     // NB: transactions are sorted in apply order here
 *     // fees for all transactions are processed first
 *     // followed by applying transactions
 *     TransactionResultMeta txProcessing<>;
 * 
 *     // upgrades are applied last
 *     UpgradeEntryMeta upgradesProcessing<>;
 * 
 *     // other misc information attached to the ledger close
 *     SCPHistoryEntry scpInfo<>;
 * };
 */
data class LedgerCloseMetaV0Xdr(
  val ledgerHeader: LedgerHeaderHistoryEntryXdr,
  /** NB: txSet is sorted in "Hash order" */
  val txSet: TransactionSetXdr,
  val txProcessing: List<TransactionResultMetaXdr>,
  val upgradesProcessing: List<UpgradeEntryMetaXdr>,
  val scpInfo: List<SCPHistoryEntryXdr>
) {
  companion object {

    fun decode(reader: XdrReader): LedgerCloseMetaV0Xdr {
      val ledgerHeader = LedgerHeaderHistoryEntryXdr.decode(reader)
      val txSet = TransactionSetXdr.decode(reader)
      val txProcessing = List(reader.readInt()) { TransactionResultMetaXdr.decode(reader) }
      val upgradesProcessing = List(reader.readInt()) { UpgradeEntryMetaXdr.decode(reader) }
      val scpInfo = List(reader.readInt()) { SCPHistoryEntryXdr.decode(reader) }
      return LedgerCloseMetaV0Xdr(ledgerHeader, txSet, txProcessing, upgradesProcessing, scpInfo)
    }
  }

  fun encode(writer: XdrWriter) {
    ledgerHeader.encode(writer)
    txSet.encode(writer)
    writer.writeInt(txProcessing.size)
    txProcessing.forEach { item ->
      item.encode(writer)
    }
    writer.writeInt(upgradesProcessing.size)
    upgradesProcessing.forEach { item ->
      item.encode(writer)
    }
    writer.writeInt(scpInfo.size)
    scpInfo.forEach { item ->
      item.encode(writer)
    }
  }
}
