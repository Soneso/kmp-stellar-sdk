// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * union SCVal switch (SCValType type)
 * {
 * 
 * case SCV_BOOL:
 *     bool b;
 * case SCV_VOID:
 *     void;
 * case SCV_ERROR:
 *     SCError error;
 * 
 * case SCV_U32:
 *     uint32 u32;
 * case SCV_I32:
 *     int32 i32;
 * 
 * case SCV_U64:
 *     uint64 u64;
 * case SCV_I64:
 *     int64 i64;
 * case SCV_TIMEPOINT:
 *     TimePoint timepoint;
 * case SCV_DURATION:
 *     Duration duration;
 * 
 * case SCV_U128:
 *     UInt128Parts u128;
 * case SCV_I128:
 *     Int128Parts i128;
 * 
 * case SCV_U256:
 *     UInt256Parts u256;
 * case SCV_I256:
 *     Int256Parts i256;
 * 
 * case SCV_BYTES:
 *     SCBytes bytes;
 * case SCV_STRING:
 *     SCString str;
 * case SCV_SYMBOL:
 *     SCSymbol sym;
 * 
 * // Vec and Map are recursive so need to live
 * // behind an option, due to xdrpp limitations.
 * case SCV_VEC:
 *     SCVec *vec;
 * case SCV_MAP:
 *     SCMap *map;
 * 
 * case SCV_ADDRESS:
 *     SCAddress address;
 * 
 * // Special SCVals reserved for system-constructed contract-data
 * // ledger keys, not generally usable elsewhere.
 * case SCV_CONTRACT_INSTANCE:
 *     SCContractInstance instance;
 * case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
 *     void;
 * case SCV_LEDGER_KEY_NONCE:
 *     SCNonceKey nonce_key;
 * };
 */
sealed class SCValXdr {
  abstract val discriminant: SCValTypeXdr

  data class B(
    val value: Boolean
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_BOOL
  }

  data class Error(
    val value: SCErrorXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_ERROR
  }

  data class U32(
    val value: Uint32Xdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_U32
  }

  data class I32(
    val value: Int32Xdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_I32
  }

  data class U64(
    val value: Uint64Xdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_U64
  }

  data class I64(
    val value: Int64Xdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_I64
  }

  data class Timepoint(
    val value: TimePointXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_TIMEPOINT
  }

  data class Duration(
    val value: DurationXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_DURATION
  }

  data class U128(
    val value: UInt128PartsXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_U128
  }

  data class I128(
    val value: Int128PartsXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_I128
  }

  data class U256(
    val value: UInt256PartsXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_U256
  }

  data class I256(
    val value: Int256PartsXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_I256
  }

  data class Bytes(
    val value: SCBytesXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_BYTES
  }

  data class Str(
    val value: SCStringXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_STRING
  }

  data class Sym(
    val value: SCSymbolXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_SYMBOL
  }

  /**
   * Vec and Map are recursive so need to live
   * behind an option, due to xdrpp limitations.
   */
  data class Vec(
    val value: SCVecXdr?
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_VEC
  }

  data class Map(
    val value: SCMapXdr?
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_MAP
  }

  data class Address(
    val value: SCAddressXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_ADDRESS
  }

  /**
   * Special SCVals reserved for system-constructed contract-data
   * ledger keys, not generally usable elsewhere.
   */
  data class Instance(
    val value: SCContractInstanceXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_CONTRACT_INSTANCE
  }

  data class NonceKey(
    val value: SCNonceKeyXdr
  ) : SCValXdr() {
    override val discriminant: SCValTypeXdr = SCValTypeXdr.SCV_LEDGER_KEY_NONCE
  }

  data class Void(
    override val discriminant: SCValTypeXdr
  ) : SCValXdr()

  companion object {

    fun decode(reader: XdrReader): SCValXdr {
      val discriminant = SCValTypeXdr.decode(reader)
      return when (discriminant) {
        SCValTypeXdr.SCV_BOOL -> {
          val value = reader.readBoolean()
          B(value)
        }
        SCValTypeXdr.SCV_VOID -> Void(discriminant)
        SCValTypeXdr.SCV_ERROR -> {
          val value = SCErrorXdr.decode(reader)
          Error(value)
        }
        SCValTypeXdr.SCV_U32 -> {
          val value = Uint32Xdr.decode(reader)
          U32(value)
        }
        SCValTypeXdr.SCV_I32 -> {
          val value = Int32Xdr.decode(reader)
          I32(value)
        }
        SCValTypeXdr.SCV_U64 -> {
          val value = Uint64Xdr.decode(reader)
          U64(value)
        }
        SCValTypeXdr.SCV_I64 -> {
          val value = Int64Xdr.decode(reader)
          I64(value)
        }
        SCValTypeXdr.SCV_TIMEPOINT -> {
          val value = TimePointXdr.decode(reader)
          Timepoint(value)
        }
        SCValTypeXdr.SCV_DURATION -> {
          val value = DurationXdr.decode(reader)
          Duration(value)
        }
        SCValTypeXdr.SCV_U128 -> {
          val value = UInt128PartsXdr.decode(reader)
          U128(value)
        }
        SCValTypeXdr.SCV_I128 -> {
          val value = Int128PartsXdr.decode(reader)
          I128(value)
        }
        SCValTypeXdr.SCV_U256 -> {
          val value = UInt256PartsXdr.decode(reader)
          U256(value)
        }
        SCValTypeXdr.SCV_I256 -> {
          val value = Int256PartsXdr.decode(reader)
          I256(value)
        }
        SCValTypeXdr.SCV_BYTES -> {
          val value = SCBytesXdr.decode(reader)
          Bytes(value)
        }
        SCValTypeXdr.SCV_STRING -> {
          val value = SCStringXdr.decode(reader)
          Str(value)
        }
        SCValTypeXdr.SCV_SYMBOL -> {
          val value = SCSymbolXdr.decode(reader)
          Sym(value)
        }
        SCValTypeXdr.SCV_VEC -> {
          val value = if (reader.readBoolean()) SCVecXdr.decode(reader) else null
          Vec(value)
        }
        SCValTypeXdr.SCV_MAP -> {
          val value = if (reader.readBoolean()) SCMapXdr.decode(reader) else null
          Map(value)
        }
        SCValTypeXdr.SCV_ADDRESS -> {
          val value = SCAddressXdr.decode(reader)
          Address(value)
        }
        SCValTypeXdr.SCV_CONTRACT_INSTANCE -> {
          val value = SCContractInstanceXdr.decode(reader)
          Instance(value)
        }
        SCValTypeXdr.SCV_LEDGER_KEY_CONTRACT_INSTANCE -> Void(discriminant)
        SCValTypeXdr.SCV_LEDGER_KEY_NONCE -> {
          val value = SCNonceKeyXdr.decode(reader)
          NonceKey(value)
        }
        else -> throw IllegalArgumentException("Unknown SCValXdr discriminant: $discriminant")
      }
    }
  }

  fun encode(writer: XdrWriter) {
    discriminant.encode(writer)
    when (this) {
      is B -> {
        writer.writeBoolean(value)
      }
      is Void -> {}
      is Error -> {
        value.encode(writer)
      }
      is U32 -> {
        value.encode(writer)
      }
      is I32 -> {
        value.encode(writer)
      }
      is U64 -> {
        value.encode(writer)
      }
      is I64 -> {
        value.encode(writer)
      }
      is Timepoint -> {
        value.encode(writer)
      }
      is Duration -> {
        value.encode(writer)
      }
      is U128 -> {
        value.encode(writer)
      }
      is I128 -> {
        value.encode(writer)
      }
      is U256 -> {
        value.encode(writer)
      }
      is I256 -> {
        value.encode(writer)
      }
      is Bytes -> {
        value.encode(writer)
      }
      is Str -> {
        value.encode(writer)
      }
      is Sym -> {
        value.encode(writer)
      }
      is Vec -> {
        if (value != null) {
          writer.writeBoolean(true)
          value.encode(writer)
        } else {
          writer.writeBoolean(false)
        }
      }
      is Map -> {
        if (value != null) {
          writer.writeBoolean(true)
          value.encode(writer)
        } else {
          writer.writeBoolean(false)
        }
      }
      is Address -> {
        value.encode(writer)
      }
      is Instance -> {
        value.encode(writer)
      }
      is Void -> {}
      is NonceKey -> {
        value.encode(writer)
      }
    }
  }
}
