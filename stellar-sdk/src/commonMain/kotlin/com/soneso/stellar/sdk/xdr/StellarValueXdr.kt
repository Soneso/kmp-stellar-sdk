// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * struct StellarValue
 * {
 *     Hash txSetHash;      // transaction set to apply to previous ledger
 *     TimePoint closeTime; // network close time
 * 
 *     // upgrades to apply to the previous ledger (usually empty)
 *     // this is a vector of encoded 'LedgerUpgrade' so that nodes can drop
 *     // unknown steps during consensus if needed.
 *     // see notes below on 'LedgerUpgrade' for more detail
 *     // max size is dictated by number of upgrade types (+ room for future)
 *     UpgradeType upgrades<6>;
 * 
 *     // reserved for future use
 *     union switch (StellarValueType v)
 *     {
 *     case STELLAR_VALUE_BASIC:
 *         void;
 *     case STELLAR_VALUE_SIGNED:
 *         LedgerCloseValueSignature lcValueSignature;
 *     }
 *     ext;
 * };
 */
data class StellarValueXdr(
  /** transaction set to apply to previous ledger */
  val txSetHash: HashXdr,
  /** network close time */
  val closeTime: TimePointXdr,
  val upgrades: List<UpgradeTypeXdr>,
  val ext: StellarValueExtXdr
) {
  companion object {

    fun decode(reader: XdrReader): StellarValueXdr {
      val txSetHash = HashXdr.decode(reader)
      val closeTime = TimePointXdr.decode(reader)
      val upgrades = List(reader.readInt()) { UpgradeTypeXdr.decode(reader) }
      val ext = StellarValueExtXdr.decode(reader)
      return StellarValueXdr(txSetHash, closeTime, upgrades, ext)
    }
  }

  fun encode(writer: XdrWriter) {
    txSetHash.encode(writer)
    closeTime.encode(writer)
    writer.writeInt(upgrades.size)
    upgrades.forEach { item ->
      item.encode(writer)
    }
    ext.encode(writer)
  }
}
