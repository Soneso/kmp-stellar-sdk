// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.soneso.stellar.sdk.xdr

/**
 * XDR Source:
 * struct PreconditionsV2
 * {
 *     TimeBounds* timeBounds;
 * 
 *     // Transaction only valid for ledger numbers n such that
 *     // minLedger <= n < maxLedger (if maxLedger == 0, then
 *     // only minLedger is checked)
 *     LedgerBounds* ledgerBounds;
 * 
 *     // If NULL, only valid when sourceAccount's sequence number
 *     // is seqNum - 1.  Otherwise, valid when sourceAccount's
 *     // sequence number n satisfies minSeqNum <= n < tx.seqNum.
 *     // Note that after execution the account's sequence number
 *     // is always raised to tx.seqNum, and a transaction is not
 *     // valid if tx.seqNum is too high to ensure replay protection.
 *     SequenceNumber* minSeqNum;
 * 
 *     // For the transaction to be valid, the current ledger time must
 *     // be at least minSeqAge greater than sourceAccount's seqTime.
 *     Duration minSeqAge;
 * 
 *     // For the transaction to be valid, the current ledger number
 *     // must be at least minSeqLedgerGap greater than sourceAccount's
 *     // seqLedger.
 *     uint32 minSeqLedgerGap;
 * 
 *     // For the transaction to be valid, there must be a signature
 *     // corresponding to every Signer in this array, even if the
 *     // signature is not otherwise required by the sourceAccount or
 *     // operations.
 *     SignerKey extraSigners<2>;
 * };
 */
data class PreconditionsV2Xdr(
  val timeBounds: TimeBoundsXdr?,
  /**
   * Transaction only valid for ledger numbers n such that
   * minLedger <= n < maxLedger (if maxLedger == 0, then
   * only minLedger is checked)
   */
  val ledgerBounds: LedgerBoundsXdr?,
  /**
   * If NULL, only valid when sourceAccount's sequence number
   * is seqNum - 1.  Otherwise, valid when sourceAccount's
   * sequence number n satisfies minSeqNum <= n < tx.seqNum.
   * Note that after execution the account's sequence number
   * is always raised to tx.seqNum, and a transaction is not
   * valid if tx.seqNum is too high to ensure replay protection.
   */
  val minSeqNum: SequenceNumberXdr?,
  /**
   * For the transaction to be valid, the current ledger time must
   * be at least minSeqAge greater than sourceAccount's seqTime.
   */
  val minSeqAge: DurationXdr,
  /**
   * For the transaction to be valid, the current ledger number
   * must be at least minSeqLedgerGap greater than sourceAccount's
   * seqLedger.
   */
  val minSeqLedgerGap: Uint32Xdr,
  val extraSigners: List<SignerKeyXdr>
) {
  companion object {

    fun decode(reader: XdrReader): PreconditionsV2Xdr {
      val timeBounds = if (reader.readBoolean()) TimeBoundsXdr.decode(reader) else null
      val ledgerBounds = if (reader.readBoolean()) LedgerBoundsXdr.decode(reader) else null
      val minSeqNum = if (reader.readBoolean()) SequenceNumberXdr.decode(reader) else null
      val minSeqAge = DurationXdr.decode(reader)
      val minSeqLedgerGap = Uint32Xdr.decode(reader)
      val extraSigners = List(reader.readInt()) { SignerKeyXdr.decode(reader) }
      return PreconditionsV2Xdr(timeBounds, ledgerBounds, minSeqNum, minSeqAge, minSeqLedgerGap, extraSigners)
    }
  }

  fun encode(writer: XdrWriter) {
    if (timeBounds != null) {
      writer.writeBoolean(true)
      timeBounds.encode(writer)
    } else {
      writer.writeBoolean(false)
    }
    if (ledgerBounds != null) {
      writer.writeBoolean(true)
      ledgerBounds.encode(writer)
    } else {
      writer.writeBoolean(false)
    }
    if (minSeqNum != null) {
      writer.writeBoolean(true)
      minSeqNum.encode(writer)
    } else {
      writer.writeBoolean(false)
    }
    minSeqAge.encode(writer)
    minSeqLedgerGap.encode(writer)
    writer.writeInt(extraSigners.size)
    extraSigners.forEach { item ->
      item.encode(writer)
    }
  }
}
