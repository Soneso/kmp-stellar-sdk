// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.stellar.sdk.xdr

/**
 * XDR Source:
 * union switch (TransactionResultCode code)
 *     {
 *     case txFEE_BUMP_INNER_SUCCESS:
 *     case txFEE_BUMP_INNER_FAILED:
 *         InnerTransactionResultPair innerResultPair;
 *     case txSUCCESS:
 *     case txFAILED:
 *         OperationResult results<>;
 *     case txTOO_EARLY:
 *     case txTOO_LATE:
 *     case txMISSING_OPERATION:
 *     case txBAD_SEQ:
 *     case txBAD_AUTH:
 *     case txINSUFFICIENT_BALANCE:
 *     case txNO_ACCOUNT:
 *     case txINSUFFICIENT_FEE:
 *     case txBAD_AUTH_EXTRA:
 *     case txINTERNAL_ERROR:
 *     case txNOT_SUPPORTED:
 *     // case txFEE_BUMP_INNER_FAILED: handled above
 *     case txBAD_SPONSORSHIP:
 *     case txBAD_MIN_SEQ_AGE_OR_GAP:
 *     case txMALFORMED:
 *     case txSOROBAN_INVALID:
 *         void;
 *     }
 */
sealed class TransactionResultResultXdr {
  abstract val discriminant: TransactionResultCodeXdr

  data class InnerResultPair(
    val value: InnerTransactionResultPairXdr
  ) : TransactionResultResultXdr() {
    override val discriminant: TransactionResultCodeXdr = TransactionResultCodeXdr.txFEE_BUMP_INNER_SUCCESS
  }

  data class Results(
    val value: List<OperationResultXdr>
  ) : TransactionResultResultXdr() {
    override val discriminant: TransactionResultCodeXdr = TransactionResultCodeXdr.txSUCCESS
  }

  /** case txFEE_BUMP_INNER_FAILED: handled above */
  data object Void : TransactionResultResultXdr() {
    override val discriminant: TransactionResultCodeXdr = TransactionResultCodeXdr.txTOO_EARLY
  }

  companion object {

    fun decode(reader: XdrReader): TransactionResultResultXdr {
      val discriminant = TransactionResultCodeXdr.decode(reader)
      return when (discriminant) {
        TransactionResultCodeXdr.txFEE_BUMP_INNER_SUCCESS -> {
          val value = InnerTransactionResultPairXdr.decode(reader)
          InnerResultPair(value)
        }
        TransactionResultCodeXdr.txFEE_BUMP_INNER_FAILED -> {
          val value = InnerTransactionResultPairXdr.decode(reader)
          InnerResultPair(value)
        }
        TransactionResultCodeXdr.txSUCCESS -> {
          val value = List(reader.readInt()) { OperationResultXdr.decode(reader) }
          Results(value)
        }
        TransactionResultCodeXdr.txFAILED -> {
          val value = List(reader.readInt()) { OperationResultXdr.decode(reader) }
          Results(value)
        }
        TransactionResultCodeXdr.txTOO_EARLY -> Void
        TransactionResultCodeXdr.txTOO_LATE -> Void
        TransactionResultCodeXdr.txMISSING_OPERATION -> Void
        TransactionResultCodeXdr.txBAD_SEQ -> Void
        TransactionResultCodeXdr.txBAD_AUTH -> Void
        TransactionResultCodeXdr.txINSUFFICIENT_BALANCE -> Void
        TransactionResultCodeXdr.txNO_ACCOUNT -> Void
        TransactionResultCodeXdr.txINSUFFICIENT_FEE -> Void
        TransactionResultCodeXdr.txBAD_AUTH_EXTRA -> Void
        TransactionResultCodeXdr.txINTERNAL_ERROR -> Void
        TransactionResultCodeXdr.txNOT_SUPPORTED -> Void
        TransactionResultCodeXdr.txBAD_SPONSORSHIP -> Void
        TransactionResultCodeXdr.txBAD_MIN_SEQ_AGE_OR_GAP -> Void
        TransactionResultCodeXdr.txMALFORMED -> Void
        TransactionResultCodeXdr.txSOROBAN_INVALID -> Void
        else -> throw IllegalArgumentException("Unknown TransactionResultResultXdr discriminant: $discriminant")
      }
    }
  }

  fun encode(writer: XdrWriter) {
    discriminant.encode(writer)
    when (this) {
      is InnerResultPair -> {
        value.encode(writer)
      }
      is Results -> {
        writer.writeInt(value.size)
        value.forEach { item ->
          item.encode(writer)
        }
      }
      is Void -> {}
    }
  }
}
