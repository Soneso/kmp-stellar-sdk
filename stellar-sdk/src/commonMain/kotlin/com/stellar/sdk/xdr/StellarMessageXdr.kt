// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.stellar.sdk.xdr

/**
 * XDR Source:
 * union StellarMessage switch (MessageType type)
 * {
 * case ERROR_MSG:
 *     Error error;
 * case HELLO:
 *     Hello hello;
 * case AUTH:
 *     Auth auth;
 * case DONT_HAVE:
 *     DontHave dontHave;
 * case PEERS:
 *     PeerAddress peers<100>;
 * 
 * case GET_TX_SET:
 *     uint256 txSetHash;
 * case TX_SET:
 *     TransactionSet txSet;
 * case GENERALIZED_TX_SET:
 *     GeneralizedTransactionSet generalizedTxSet;
 * 
 * case TRANSACTION:
 *     TransactionEnvelope transaction;
 * 
 * case TIME_SLICED_SURVEY_REQUEST:
 *     SignedTimeSlicedSurveyRequestMessage signedTimeSlicedSurveyRequestMessage;
 * 
 * case TIME_SLICED_SURVEY_RESPONSE:
 *     SignedTimeSlicedSurveyResponseMessage signedTimeSlicedSurveyResponseMessage;
 * 
 * case TIME_SLICED_SURVEY_START_COLLECTING:
 *     SignedTimeSlicedSurveyStartCollectingMessage
 *         signedTimeSlicedSurveyStartCollectingMessage;
 * 
 * case TIME_SLICED_SURVEY_STOP_COLLECTING:
 *     SignedTimeSlicedSurveyStopCollectingMessage
 *         signedTimeSlicedSurveyStopCollectingMessage;
 * 
 * // SCP
 * case GET_SCP_QUORUMSET:
 *     uint256 qSetHash;
 * case SCP_QUORUMSET:
 *     SCPQuorumSet qSet;
 * case SCP_MESSAGE:
 *     SCPEnvelope envelope;
 * case GET_SCP_STATE:
 *     uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
 * case SEND_MORE:
 *     SendMore sendMoreMessage;
 * case SEND_MORE_EXTENDED:
 *     SendMoreExtended sendMoreExtendedMessage;
 * // Pull mode
 * case FLOOD_ADVERT:
 *      FloodAdvert floodAdvert;
 * case FLOOD_DEMAND:
 *      FloodDemand floodDemand;
 * };
 */
sealed class StellarMessageXdr {
  abstract val discriminant: MessageTypeXdr

  data class Error(
    val value: ErrorXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.ERROR_MSG
  }

  data class Hello(
    val value: HelloXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.HELLO
  }

  data class Auth(
    val value: AuthXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.AUTH
  }

  data class DontHave(
    val value: DontHaveXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.DONT_HAVE
  }

  data class Peers(
    val value: List<PeerAddressXdr>
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.PEERS
  }

  data class TxSetHash(
    val value: Uint256Xdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.GET_TX_SET
  }

  data class TxSet(
    val value: TransactionSetXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TX_SET
  }

  data class GeneralizedTxSet(
    val value: GeneralizedTransactionSetXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.GENERALIZED_TX_SET
  }

  data class Transaction(
    val value: TransactionEnvelopeXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TRANSACTION
  }

  data class SignedTimeSlicedSurveyRequestMessage(
    val value: SignedTimeSlicedSurveyRequestMessageXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TIME_SLICED_SURVEY_REQUEST
  }

  data class SignedTimeSlicedSurveyResponseMessage(
    val value: SignedTimeSlicedSurveyResponseMessageXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TIME_SLICED_SURVEY_RESPONSE
  }

  data class SignedTimeSlicedSurveyStartCollectingMessage(
    val value: SignedTimeSlicedSurveyStartCollectingMessageXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TIME_SLICED_SURVEY_START_COLLECTING
  }

  data class SignedTimeSlicedSurveyStopCollectingMessage(
    val value: SignedTimeSlicedSurveyStopCollectingMessageXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.TIME_SLICED_SURVEY_STOP_COLLECTING
  }

  /** SCP */
  data class QSetHash(
    val value: Uint256Xdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.GET_SCP_QUORUMSET
  }

  data class QSet(
    val value: SCPQuorumSetXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.SCP_QUORUMSET
  }

  data class Envelope(
    val value: SCPEnvelopeXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.SCP_MESSAGE
  }

  data class GetSCPLedgerSeq(
    val value: Uint32Xdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.GET_SCP_STATE
  }

  data class SendMoreMessage(
    val value: SendMoreXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.SEND_MORE
  }

  data class SendMoreExtendedMessage(
    val value: SendMoreExtendedXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.SEND_MORE_EXTENDED
  }

  /** Pull mode */
  data class FloodAdvert(
    val value: FloodAdvertXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.FLOOD_ADVERT
  }

  data class FloodDemand(
    val value: FloodDemandXdr
  ) : StellarMessageXdr() {
    override val discriminant: MessageTypeXdr = MessageTypeXdr.FLOOD_DEMAND
  }

  companion object {

    fun decode(reader: XdrReader): StellarMessageXdr {
      val discriminant = MessageTypeXdr.decode(reader)
      return when (discriminant) {
        MessageTypeXdr.ERROR_MSG -> {
          val value = ErrorXdr.decode(reader)
          Error(value)
        }
        MessageTypeXdr.HELLO -> {
          val value = HelloXdr.decode(reader)
          Hello(value)
        }
        MessageTypeXdr.AUTH -> {
          val value = AuthXdr.decode(reader)
          Auth(value)
        }
        MessageTypeXdr.DONT_HAVE -> {
          val value = DontHaveXdr.decode(reader)
          DontHave(value)
        }
        MessageTypeXdr.PEERS -> {
          val value = List(reader.readInt()) { PeerAddressXdr.decode(reader) }
          Peers(value)
        }
        MessageTypeXdr.GET_TX_SET -> {
          val value = Uint256Xdr.decode(reader)
          TxSetHash(value)
        }
        MessageTypeXdr.TX_SET -> {
          val value = TransactionSetXdr.decode(reader)
          TxSet(value)
        }
        MessageTypeXdr.GENERALIZED_TX_SET -> {
          val value = GeneralizedTransactionSetXdr.decode(reader)
          GeneralizedTxSet(value)
        }
        MessageTypeXdr.TRANSACTION -> {
          val value = TransactionEnvelopeXdr.decode(reader)
          Transaction(value)
        }
        MessageTypeXdr.TIME_SLICED_SURVEY_REQUEST -> {
          val value = SignedTimeSlicedSurveyRequestMessageXdr.decode(reader)
          SignedTimeSlicedSurveyRequestMessage(value)
        }
        MessageTypeXdr.TIME_SLICED_SURVEY_RESPONSE -> {
          val value = SignedTimeSlicedSurveyResponseMessageXdr.decode(reader)
          SignedTimeSlicedSurveyResponseMessage(value)
        }
        MessageTypeXdr.TIME_SLICED_SURVEY_START_COLLECTING -> {
          val value = SignedTimeSlicedSurveyStartCollectingMessageXdr.decode(reader)
          SignedTimeSlicedSurveyStartCollectingMessage(value)
        }
        MessageTypeXdr.TIME_SLICED_SURVEY_STOP_COLLECTING -> {
          val value = SignedTimeSlicedSurveyStopCollectingMessageXdr.decode(reader)
          SignedTimeSlicedSurveyStopCollectingMessage(value)
        }
        MessageTypeXdr.GET_SCP_QUORUMSET -> {
          val value = Uint256Xdr.decode(reader)
          QSetHash(value)
        }
        MessageTypeXdr.SCP_QUORUMSET -> {
          val value = SCPQuorumSetXdr.decode(reader)
          QSet(value)
        }
        MessageTypeXdr.SCP_MESSAGE -> {
          val value = SCPEnvelopeXdr.decode(reader)
          Envelope(value)
        }
        MessageTypeXdr.GET_SCP_STATE -> {
          val value = Uint32Xdr.decode(reader)
          GetSCPLedgerSeq(value)
        }
        MessageTypeXdr.SEND_MORE -> {
          val value = SendMoreXdr.decode(reader)
          SendMoreMessage(value)
        }
        MessageTypeXdr.SEND_MORE_EXTENDED -> {
          val value = SendMoreExtendedXdr.decode(reader)
          SendMoreExtendedMessage(value)
        }
        MessageTypeXdr.FLOOD_ADVERT -> {
          val value = FloodAdvertXdr.decode(reader)
          FloodAdvert(value)
        }
        MessageTypeXdr.FLOOD_DEMAND -> {
          val value = FloodDemandXdr.decode(reader)
          FloodDemand(value)
        }
        else -> throw IllegalArgumentException("Unknown StellarMessageXdr discriminant: $discriminant")
      }
    }
  }

  fun encode(writer: XdrWriter) {
    discriminant.encode(writer)
    when (this) {
      is Error -> {
        value.encode(writer)
      }
      is Hello -> {
        value.encode(writer)
      }
      is Auth -> {
        value.encode(writer)
      }
      is DontHave -> {
        value.encode(writer)
      }
      is Peers -> {
        writer.writeInt(value.size)
        value.forEach { item ->
          item.encode(writer)
        }
      }
      is TxSetHash -> {
        value.encode(writer)
      }
      is TxSet -> {
        value.encode(writer)
      }
      is GeneralizedTxSet -> {
        value.encode(writer)
      }
      is Transaction -> {
        value.encode(writer)
      }
      is SignedTimeSlicedSurveyRequestMessage -> {
        value.encode(writer)
      }
      is SignedTimeSlicedSurveyResponseMessage -> {
        value.encode(writer)
      }
      is SignedTimeSlicedSurveyStartCollectingMessage -> {
        value.encode(writer)
      }
      is SignedTimeSlicedSurveyStopCollectingMessage -> {
        value.encode(writer)
      }
      is QSetHash -> {
        value.encode(writer)
      }
      is QSet -> {
        value.encode(writer)
      }
      is Envelope -> {
        value.encode(writer)
      }
      is GetSCPLedgerSeq -> {
        value.encode(writer)
      }
      is SendMoreMessage -> {
        value.encode(writer)
      }
      is SendMoreExtendedMessage -> {
        value.encode(writer)
      }
      is FloodAdvert -> {
        value.encode(writer)
      }
      is FloodDemand -> {
        value.encode(writer)
      }
    }
  }
}
