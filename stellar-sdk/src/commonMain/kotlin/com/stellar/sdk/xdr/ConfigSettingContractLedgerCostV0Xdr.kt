// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.stellar.sdk.xdr

/**
 * XDR Source:
 * struct ConfigSettingContractLedgerCostV0
 * {
 *     // Maximum number of disk entry read operations per ledger
 *     uint32 ledgerMaxDiskReadEntries;
 *     // Maximum number of bytes of disk reads that can be performed per ledger
 *     uint32 ledgerMaxDiskReadBytes;
 *     // Maximum number of ledger entry write operations per ledger
 *     uint32 ledgerMaxWriteLedgerEntries;
 *     // Maximum number of bytes that can be written per ledger
 *     uint32 ledgerMaxWriteBytes;
 * 
 *     // Maximum number of disk entry read operations per transaction
 *     uint32 txMaxDiskReadEntries;
 *     // Maximum number of bytes of disk reads that can be performed per transaction
 *     uint32 txMaxDiskReadBytes;
 *     // Maximum number of ledger entry write operations per transaction
 *     uint32 txMaxWriteLedgerEntries;
 *     // Maximum number of bytes that can be written per transaction
 *     uint32 txMaxWriteBytes;
 * 
 *     int64 feeDiskReadLedgerEntry;  // Fee per disk ledger entry read
 *     int64 feeWriteLedgerEntry;     // Fee per ledger entry write
 * 
 *     int64 feeDiskRead1KB;          // Fee for reading 1KB disk
 * 
 *     // The following parameters determine the write fee per 1KB.
 *     // Rent fee grows linearly until soroban state reaches this size
 *     int64 sorobanStateTargetSizeBytes;
 *     // Fee per 1KB rent when the soroban state is empty
 *     int64 rentFee1KBSorobanStateSizeLow;
 *     // Fee per 1KB rent when the soroban state has reached `sorobanStateTargetSizeBytes`
 *     int64 rentFee1KBSorobanStateSizeHigh;
 *     // Rent fee multiplier for any additional data past the first `sorobanStateTargetSizeBytes`
 *     uint32 sorobanStateRentFeeGrowthFactor;
 * };
 */
data class ConfigSettingContractLedgerCostV0Xdr(
  /** Maximum number of disk entry read operations per ledger */
  val ledgerMaxDiskReadEntries: Uint32Xdr,
  /** Maximum number of bytes of disk reads that can be performed per ledger */
  val ledgerMaxDiskReadBytes: Uint32Xdr,
  /** Maximum number of ledger entry write operations per ledger */
  val ledgerMaxWriteLedgerEntries: Uint32Xdr,
  /** Maximum number of bytes that can be written per ledger */
  val ledgerMaxWriteBytes: Uint32Xdr,
  /** Maximum number of disk entry read operations per transaction */
  val txMaxDiskReadEntries: Uint32Xdr,
  /** Maximum number of bytes of disk reads that can be performed per transaction */
  val txMaxDiskReadBytes: Uint32Xdr,
  /** Maximum number of ledger entry write operations per transaction */
  val txMaxWriteLedgerEntries: Uint32Xdr,
  /** Maximum number of bytes that can be written per transaction */
  val txMaxWriteBytes: Uint32Xdr,
  /** Fee per disk ledger entry read */
  val feeDiskReadLedgerEntry: Int64Xdr,
  /** Fee per ledger entry write */
  val feeWriteLedgerEntry: Int64Xdr,
  /** Fee for reading 1KB disk */
  val feeDiskRead1Kb: Int64Xdr,
  /**
   * The following parameters determine the write fee per 1KB.
   * Rent fee grows linearly until soroban state reaches this size
   */
  val sorobanStateTargetSizeBytes: Int64Xdr,
  /** Fee per 1KB rent when the soroban state is empty */
  val rentFee1KbSorobanStateSizeLow: Int64Xdr,
  /** Fee per 1KB rent when the soroban state has reached `sorobanStateTargetSizeBytes` */
  val rentFee1KbSorobanStateSizeHigh: Int64Xdr,
  /** Rent fee multiplier for any additional data past the first `sorobanStateTargetSizeBytes` */
  val sorobanStateRentFeeGrowthFactor: Uint32Xdr
) {
  companion object {

    fun decode(reader: XdrReader): ConfigSettingContractLedgerCostV0Xdr {
      val ledgerMaxDiskReadEntries = Uint32Xdr.decode(reader)
      val ledgerMaxDiskReadBytes = Uint32Xdr.decode(reader)
      val ledgerMaxWriteLedgerEntries = Uint32Xdr.decode(reader)
      val ledgerMaxWriteBytes = Uint32Xdr.decode(reader)
      val txMaxDiskReadEntries = Uint32Xdr.decode(reader)
      val txMaxDiskReadBytes = Uint32Xdr.decode(reader)
      val txMaxWriteLedgerEntries = Uint32Xdr.decode(reader)
      val txMaxWriteBytes = Uint32Xdr.decode(reader)
      val feeDiskReadLedgerEntry = Int64Xdr.decode(reader)
      val feeWriteLedgerEntry = Int64Xdr.decode(reader)
      val feeDiskRead1Kb = Int64Xdr.decode(reader)
      val sorobanStateTargetSizeBytes = Int64Xdr.decode(reader)
      val rentFee1KbSorobanStateSizeLow = Int64Xdr.decode(reader)
      val rentFee1KbSorobanStateSizeHigh = Int64Xdr.decode(reader)
      val sorobanStateRentFeeGrowthFactor = Uint32Xdr.decode(reader)
      return ConfigSettingContractLedgerCostV0Xdr(ledgerMaxDiskReadEntries, ledgerMaxDiskReadBytes, ledgerMaxWriteLedgerEntries, ledgerMaxWriteBytes, txMaxDiskReadEntries, txMaxDiskReadBytes, txMaxWriteLedgerEntries, txMaxWriteBytes, feeDiskReadLedgerEntry, feeWriteLedgerEntry, feeDiskRead1Kb, sorobanStateTargetSizeBytes, rentFee1KbSorobanStateSizeLow, rentFee1KbSorobanStateSizeHigh, sorobanStateRentFeeGrowthFactor)
    }
  }

  fun encode(writer: XdrWriter) {
    ledgerMaxDiskReadEntries.encode(writer)
    ledgerMaxDiskReadBytes.encode(writer)
    ledgerMaxWriteLedgerEntries.encode(writer)
    ledgerMaxWriteBytes.encode(writer)
    txMaxDiskReadEntries.encode(writer)
    txMaxDiskReadBytes.encode(writer)
    txMaxWriteLedgerEntries.encode(writer)
    txMaxWriteBytes.encode(writer)
    feeDiskReadLedgerEntry.encode(writer)
    feeWriteLedgerEntry.encode(writer)
    feeDiskRead1Kb.encode(writer)
    sorobanStateTargetSizeBytes.encode(writer)
    rentFee1KbSorobanStateSizeLow.encode(writer)
    rentFee1KbSorobanStateSizeHigh.encode(writer)
    sorobanStateRentFeeGrowthFactor.encode(writer)
  }
}
