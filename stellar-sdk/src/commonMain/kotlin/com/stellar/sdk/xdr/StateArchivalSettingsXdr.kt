// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.stellar.sdk.xdr

/**
 * XDR Source:
 * struct StateArchivalSettings {
 *     uint32 maxEntryTTL;
 *     uint32 minTemporaryTTL;
 *     uint32 minPersistentTTL;
 * 
 *     // rent_fee = wfee_rate_average / rent_rate_denominator_for_type
 *     int64 persistentRentRateDenominator;
 *     int64 tempRentRateDenominator;
 * 
 *     // max number of entries that emit archival meta in a single ledger
 *     uint32 maxEntriesToArchive;
 * 
 *     // Number of snapshots to use when calculating average live Soroban State size
 *     uint32 liveSorobanStateSizeWindowSampleSize;
 * 
 *     // How often to sample the live Soroban State size for the average, in ledgers
 *     uint32 liveSorobanStateSizeWindowSamplePeriod;
 * 
 *     // Maximum number of bytes that we scan for eviction per ledger
 *     uint32 evictionScanSize;
 * 
 *     // Lowest BucketList level to be scanned to evict entries
 *     uint32 startingEvictionScanLevel;
 * };
 */
data class StateArchivalSettingsXdr(
  val maxEntryTtl: Uint32Xdr,
  val minTemporaryTtl: Uint32Xdr,
  val minPersistentTtl: Uint32Xdr,
  /** rent_fee = wfee_rate_average / rent_rate_denominator_for_type */
  val persistentRentRateDenominator: Int64Xdr,
  val tempRentRateDenominator: Int64Xdr,
  /** max number of entries that emit archival meta in a single ledger */
  val maxEntriesToArchive: Uint32Xdr,
  /** Number of snapshots to use when calculating average live Soroban State size */
  val liveSorobanStateSizeWindowSampleSize: Uint32Xdr,
  /** How often to sample the live Soroban State size for the average, in ledgers */
  val liveSorobanStateSizeWindowSamplePeriod: Uint32Xdr,
  /** Maximum number of bytes that we scan for eviction per ledger */
  val evictionScanSize: Uint32Xdr,
  /** Lowest BucketList level to be scanned to evict entries */
  val startingEvictionScanLevel: Uint32Xdr
) {
  companion object {

    fun decode(reader: XdrReader): StateArchivalSettingsXdr {
      val maxEntryTtl = Uint32Xdr.decode(reader)
      val minTemporaryTtl = Uint32Xdr.decode(reader)
      val minPersistentTtl = Uint32Xdr.decode(reader)
      val persistentRentRateDenominator = Int64Xdr.decode(reader)
      val tempRentRateDenominator = Int64Xdr.decode(reader)
      val maxEntriesToArchive = Uint32Xdr.decode(reader)
      val liveSorobanStateSizeWindowSampleSize = Uint32Xdr.decode(reader)
      val liveSorobanStateSizeWindowSamplePeriod = Uint32Xdr.decode(reader)
      val evictionScanSize = Uint32Xdr.decode(reader)
      val startingEvictionScanLevel = Uint32Xdr.decode(reader)
      return StateArchivalSettingsXdr(maxEntryTtl, minTemporaryTtl, minPersistentTtl, persistentRentRateDenominator, tempRentRateDenominator, maxEntriesToArchive, liveSorobanStateSizeWindowSampleSize, liveSorobanStateSizeWindowSamplePeriod, evictionScanSize, startingEvictionScanLevel)
    }
  }

  fun encode(writer: XdrWriter) {
    maxEntryTtl.encode(writer)
    minTemporaryTtl.encode(writer)
    minPersistentTtl.encode(writer)
    persistentRentRateDenominator.encode(writer)
    tempRentRateDenominator.encode(writer)
    maxEntriesToArchive.encode(writer)
    liveSorobanStateSizeWindowSampleSize.encode(writer)
    liveSorobanStateSizeWindowSamplePeriod.encode(writer)
    evictionScanSize.encode(writer)
    startingEvictionScanLevel.encode(writer)
  }
}
