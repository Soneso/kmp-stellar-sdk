// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package com.stellar.sdk.xdr

/**
 * XDR Source:
 * struct SCPStatement
 * {
 *     NodeID nodeID;    // v
 *     uint64 slotIndex; // i
 * 
 *     union switch (SCPStatementType type)
 *     {
 *     case SCP_ST_PREPARE:
 *         struct
 *         {
 *             Hash quorumSetHash;       // D
 *             SCPBallot ballot;         // b
 *             SCPBallot* prepared;      // p
 *             SCPBallot* preparedPrime; // p'
 *             uint32 nC;                // c.n
 *             uint32 nH;                // h.n
 *         } prepare;
 *     case SCP_ST_CONFIRM:
 *         struct
 *         {
 *             SCPBallot ballot;   // b
 *             uint32 nPrepared;   // p.n
 *             uint32 nCommit;     // c.n
 *             uint32 nH;          // h.n
 *             Hash quorumSetHash; // D
 *         } confirm;
 *     case SCP_ST_EXTERNALIZE:
 *         struct
 *         {
 *             SCPBallot commit;         // c
 *             uint32 nH;                // h.n
 *             Hash commitQuorumSetHash; // D used before EXTERNALIZE
 *         } externalize;
 *     case SCP_ST_NOMINATE:
 *         SCPNomination nominate;
 *     }
 *     pledges;
 * };
 */
data class SCPStatementXdr(
  /** v */
  val nodeId: NodeIDXdr,
  /** i */
  val slotIndex: Uint64Xdr,
  val pledges: SCPStatementPledgesXdr
) {
  companion object {

    fun decode(reader: XdrReader): SCPStatementXdr {
      val nodeId = NodeIDXdr.decode(reader)
      val slotIndex = Uint64Xdr.decode(reader)
      val pledges = SCPStatementPledgesXdr.decode(reader)
      return SCPStatementXdr(nodeId, slotIndex, pledges)
    }
  }

  fun encode(writer: XdrWriter) {
    nodeId.encode(writer)
    slotIndex.encode(writer)
    pledges.encode(writer)
  }
}
