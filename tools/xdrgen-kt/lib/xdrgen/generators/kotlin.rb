# frozen_string_literal: true

module Xdrgen
  module Generators
    # Kotlin code generator for XDR definitions
    # Generates idiomatic Kotlin code with proper type mappings:
    # - enum -> enum class
    # - struct -> data class
    # - union -> sealed hierarchy
    # - arrays -> List<T> or ByteArray
    # - strings -> String
    # - opaque -> ByteArray
    class Kotlin < Base
      def generate
        @output_files = {}
        @package = @namespace.gsub('::', '.')

        # Skip XdrReader/XdrWriter generation - will be provided by KMP SDK
        # render_xdr_utils

        # Generate primitive type extensions
        render_primitive_extensions

        # Generate all type definitions
        render_definitions(@top)
      end

      private

      def render_definitions(node)
        node.definitions.each { |defn| render_definition(defn) }
        node.namespaces.each { |ns| render_definitions(ns) }
      end

      def render_nested_definitions(defn)
        return unless defn.respond_to?(:nested_definitions)
        defn.nested_definitions.each { |nested| render_definition(nested) }
      end

      def render_definition(defn)
        render_nested_definitions(defn)

        case defn
        when AST::Definitions::Struct
          render_struct(defn)
        when AST::Definitions::Enum
          render_enum(defn)
        when AST::Definitions::Union
          render_union(defn)
        when AST::Definitions::Typedef
          render_typedef(defn)
        when AST::Definitions::Const
          render_const(defn)
        end
      end

      def render_const(const)
        # Render constants as top-level const vals
        file_name = 'Constants.kt'

        # Initialize constants file if not exists
        unless @output_files&.key?(file_name)
          @output_files ||= {}
          out = @output.open(file_name)
          out.puts "// Automatically generated by xdrgen"
          out.puts "// DO NOT EDIT or your changes may be overwritten"
          out.puts
          out.puts "package #{@package}"
          out.puts
          @output_files[file_name] = out
        end

        out = @output_files[file_name]
        out.puts "const val #{const.name}: Int = #{const.value}"
      end

      def render_enum(enum)
        enum_name = name(enum)
        file_name = "#{enum_name}.kt"
        out = @output.open(file_name)

        render_file_header(out)
        render_source_comment(out, enum)

        out.puts "enum class #{enum_name}(val value: Int) {"
        out.indent do
          enum.members.each_with_index do |member, idx|
            # Extract and render comments for this member
            comments = extract_member_comment(enum.text_value, member.name)
            render_member_comment(out, comments)

            suffix = idx < enum.members.length - 1 ? ',' : ';'
            out.puts "#{member.name}(#{member.value})#{suffix}"
          end

          out.puts
          out.puts "companion object {"
          out.indent do
            out.puts ""
            out.puts "fun decode(reader: XdrReader): #{enum_name} {"
            out.indent do
              out.puts "val value = reader.readInt()"
              out.puts "return entries.find { it.value == value }"
              out.indent do
                out.puts "?: throw IllegalArgumentException(\"Unknown #{enum_name} value: \$value\")"
              end
            end
            out.puts "}"
          end
          out.puts "}"

          out.puts
          out.puts "fun encode(writer: XdrWriter) {"
          out.indent do
            out.puts "writer.writeInt(value)"
          end
          out.puts "}"
        end
        out.puts "}"

        out.close
      end

      def render_typedef(typedef)
        typedef_name = name(typedef)
        file_name = "#{typedef_name}.kt"
        out = @output.open(file_name)

        render_file_header(out)
        render_source_comment(out, typedef)

        # All typedefs become inline value classes (like Java wrappers but zero-cost)
        kotlin_type = kotlin_type_for(typedef.declaration)

        out.puts "@Suppress(\"EXPECT_ACTUAL_INCOMPATIBILITY\")"
        out.puts "@kotlin.jvm.JvmInline"
        out.puts "value class #{typedef_name}(val value: #{kotlin_type}) {"
        out.indent do
          out.puts "companion object {"
          out.indent do
            out.puts "fun decode(reader: XdrReader): #{typedef_name} {"
            out.indent do
              out.puts "val value = #{decode_expression(typedef.declaration, 'reader')}"
              out.puts "return #{typedef_name}(value)"
            end
            out.puts "}"
          end
          out.puts "}"

          out.puts
          out.puts "fun encode(writer: XdrWriter) {"
          out.indent do
            encode_statement(typedef.declaration, 'value', 'writer', out)
          end
          out.puts "}"
        end
        out.puts "}"

        out.close
      end

      def render_struct(struct)
        struct_name = name(struct)
        file_name = "#{struct_name}.kt"
        out = @output.open(file_name)

        render_file_header(out)
        render_source_comment(out, struct)

        out.puts "data class #{struct_name}("
        out.indent do
          struct.members.each_with_index do |member, idx|
            # Extract and render comments for this field
            comments = extract_member_comment(struct.text_value, member.name)
            render_member_comment(out, comments)

            member_name = escape_kotlin_keyword(member.name.underscore.camelize(:lower))
            member_type = kotlin_type_for(member.declaration)
            suffix = idx < struct.members.length - 1 ? ',' : ''
            out.puts "val #{member_name}: #{member_type}#{suffix}"
          end
        end
        out.puts ") {"
        out.indent do
          # Companion object with decode method
          out.puts "companion object {"
          out.indent do
            out.puts ""
            out.puts "fun decode(reader: XdrReader): #{struct_name} {"
            out.indent do
              struct.members.each do |member|
                base_name = member.name.underscore.camelize(:lower)
                # Use 'value' as local variable name if property is a keyword
                local_name = base_name == "val" ? "value" : base_name
                out.puts "val #{local_name} = #{decode_expression(member.declaration, 'reader')}"
              end

              param_list = struct.members.map { |m|
                base_name = m.name.underscore.camelize(:lower)
                base_name == "val" ? "value" : base_name
              }.join(', ')
              out.puts "return #{struct_name}(#{param_list})"
            end
            out.puts "}"
          end
          out.puts "}"

          # Encode method
          out.puts
          out.puts "fun encode(writer: XdrWriter) {"
          out.indent do
            struct.members.each do |member|
              member_name = escape_kotlin_keyword(member.name.underscore.camelize(:lower))
              encode_statement(member.declaration, member_name, 'writer', out)
            end
          end
          out.puts "}"
        end
        out.puts "}"

        out.close
      end

      def render_union(union)
        union_name = name(union)
        file_name = "#{union_name}.kt"
        out = @output.open(file_name)

        render_file_header(out)
        render_source_comment(out, union)

        # Sealed class hierarchy for unions
        # union.discriminant is the full declaration (has .type), union.discriminant_type is the resolved type
        discriminant_type = kotlin_type_for(union.discriminant)
        out.puts "sealed class #{union_name} {"
        out.indent do
          out.puts "abstract val discriminant: #{discriminant_type}"
          out.puts

          # Generate a subclass for each arm
          union.arms.each do |arm|
            next if arm.void?

            # Extract and render comments for this arm
            comments = extract_union_arm_comment(union.text_value, arm)
            render_member_comment(out, comments)

            arm_class_name = arm.name.camelize
            arm_type = kotlin_type_for(arm.declaration)
            is_default = arm.is_a?(AST::Definitions::UnionDefaultArm)

            if is_default
              # Default arm needs discriminant as constructor parameter
              out.puts "data class #{arm_class_name}("
              out.indent do
                out.puts "override val discriminant: #{discriminant_type},"
                out.puts "val value: #{arm_type}"
              end
              out.puts ") : #{union_name}()"
            else
              out.puts "data class #{arm_class_name}("
              out.indent do
                out.puts "val value: #{arm_type}"
              end
              out.puts ") : #{union_name}() {"
              out.indent do
                # Discriminant value
                discriminant_value = arm_discriminant_value(arm, union.discriminant)
                out.puts "override val discriminant: #{discriminant_type} = #{discriminant_value}"
              end
              out.puts "}"
            end
            out.puts
          end

          # Void arms - collect by class name to handle duplicates
          void_arms = union.arms.select(&:void?).group_by { |arm| arm.name.camelize }
          void_arms.each do |arm_class_name, arms|
            # Extract and render comments for the first arm (they're grouped by name)
            comments = extract_union_arm_comment(union.text_value, arms.first)
            render_member_comment(out, comments)

            is_default = arms.first.is_a?(AST::Definitions::UnionDefaultArm)

            if is_default
              out.puts "data class #{arm_class_name}("
              out.indent do
                out.puts "override val discriminant: #{discriminant_type}"
              end
              out.puts ") : #{union_name}()"
            elsif arms.length > 1
              # Multiple void arms with same name - need a data class with discriminant parameter
              out.puts "data class #{arm_class_name}("
              out.indent do
                out.puts "override val discriminant: #{discriminant_type}"
              end
              out.puts ") : #{union_name}()"
            else
              # Single void arm - use data object
              out.puts "data object #{arm_class_name} : #{union_name}() {"
              out.indent do
                discriminant_value = arm_discriminant_value(arms.first, union.discriminant)
                out.puts "override val discriminant: #{discriminant_type} = #{discriminant_value}"
              end
              out.puts "}"
            end
            out.puts
          end

          # Companion object with decode
          out.puts "companion object {"
          out.indent do
            out.puts ""
            out.puts "fun decode(reader: XdrReader): #{union_name} {"
            out.indent do
              out.puts "val discriminant = #{decode_expression(union.discriminant, 'reader')}"
              out.puts "return when (discriminant) {"
              out.indent do
                # Group void arms by class name to detect duplicates
                void_arms_by_class = union.normal_arms.select(&:void?).group_by { |arm| arm.name.camelize }

                union.normal_arms.each do |arm|
                  arm_class_name = arm.name.camelize
                  has_duplicate_void = arm.void? && void_arms_by_class[arm_class_name]&.length.to_i > 1

                  arm.cases.each do |c|
                    if c.value.is_a?(AST::Identifier)
                      # For enum discriminants, get the enum type name
                      discriminant_type_name = name(union.discriminant_type)
                      discriminant_value = "#{discriminant_type_name}.#{c.value.name}"
                    else
                      # Numeric literal - need to wrap in value class if discriminant is a typedef
                      literal_value = c.value.value
                      discriminant_type_name = kotlin_type_for(union.discriminant)

                      if discriminant_type_name.end_with?('Xdr')
                        # Wrap in value class constructor
                        # Resolve to underlying type to determine literal suffix
                        resolved_type = resolve_typedef_declaration(union.discriminant)
                        wrapped_value = case resolved_type.type
                        when AST::Typespecs::UnsignedInt
                          "#{literal_value}u"
                        when AST::Typespecs::UnsignedHyper
                          "#{literal_value}uL"
                        else
                          literal_value.to_s
                        end
                        discriminant_value = "#{discriminant_type_name}(#{wrapped_value})"
                      else
                        discriminant_value = literal_value.to_s
                      end
                    end

                    if arm.void?
                      if has_duplicate_void
                        # Multiple void arms with same name need discriminant passed
                        out.puts "#{discriminant_value} -> #{arm_class_name}(discriminant)"
                      else
                        # Single void arm is a data object
                        out.puts "#{discriminant_value} -> #{arm_class_name}"
                      end
                    else
                      out.puts "#{discriminant_value} -> {"
                      out.indent do
                        out.puts "val value = #{decode_expression(arm.declaration, 'reader')}"
                        out.puts "#{arm_class_name}(value)"
                      end
                      out.puts "}"
                    end
                  end
                end

                # Handle default arm if present
                if union.default_arm.present?
                  arm = union.default_arm
                  arm_class_name = arm.name.camelize
                  out.puts "else -> {"
                  out.indent do
                    if arm.void?
                      out.puts "#{arm_class_name}(discriminant)"
                    else
                      out.puts "val value = #{decode_expression(arm.declaration, 'reader')}"
                      out.puts "#{arm_class_name}(discriminant, value)"
                    end
                  end
                  out.puts "}"
                else
                  out.puts "else -> throw IllegalArgumentException(\"Unknown #{union_name} discriminant: \$discriminant\")"
                end
              end
              out.puts "}"
            end
            out.puts "}"
          end
          out.puts "}"

          # Encode method
          out.puts
          out.puts "fun encode(writer: XdrWriter) {"
          out.indent do
            encode_statement(union.discriminant, 'discriminant', 'writer', out)
            out.puts "when (this) {"
            out.indent do
              union.arms.each do |arm|
                arm_class_name = arm.name.camelize
                if arm.void?
                  out.puts "is #{arm_class_name} -> {}"
                else
                  out.puts "is #{arm_class_name} -> {"
                  out.indent do
                    encode_statement(arm.declaration, 'value', 'writer', out)
                  end
                  out.puts "}"
                end
              end
            end
            out.puts "}"
          end
          out.puts "}"
        end
        out.puts "}"

        out.close
      end

      def render_primitive_extensions
        file_name = 'XdrPrimitiveExtensions.kt'
        out = @output.open(file_name)

        out.puts <<~KOTLIN
          // Automatically generated by xdrgen
          // Extension functions for primitive types used in XDR

          package #{@package}

          // Extension functions for encoding primitive types
          fun Int.encode(writer: XdrWriter) = writer.writeInt(this)
          fun UInt.encode(writer: XdrWriter) = writer.writeUnsignedInt(this)
          fun Long.encode(writer: XdrWriter) = writer.writeLong(this)
          fun ULong.encode(writer: XdrWriter) = writer.writeUnsignedLong(this)
          fun Float.encode(writer: XdrWriter) = writer.writeFloat(this)
          fun Double.encode(writer: XdrWriter) = writer.writeDouble(this)
          fun Boolean.encode(writer: XdrWriter) = writer.writeBoolean(this)
          fun String.encode(writer: XdrWriter) = writer.writeString(this)
        KOTLIN

        out.close
      end

      def render_xdr_utils
        file_name = 'XdrReader.kt'
        out = @output.open(file_name)

        out.puts <<~KOTLIN
          // Automatically generated by xdrgen
          // DO NOT EDIT or your changes may be overwritten

          package #{@package}

          import java.io.DataInputStream
          import java.io.InputStream
          import java.nio.charset.StandardCharsets

          /**
           * XDR reader for decoding XDR-encoded data.
           */
          class XdrReader(input: InputStream) {
              private val dataInput = DataInputStream(input)

              fun readInt(): Int = dataInput.readInt()

              fun readUnsignedInt(): UInt = dataInput.readInt().toUInt()

              fun readLong(): Long = dataInput.readLong()

              fun readUnsignedLong(): ULong = dataInput.readLong().toULong()

              fun readFloat(): Float = dataInput.readFloat()

              fun readDouble(): Double = dataInput.readDouble()

              fun readBoolean(): Boolean = dataInput.readInt() != 0

              fun readString(): String {
                  val length = dataInput.readInt()
                  if (length < 0) throw IllegalArgumentException("Negative string length: \$length")
                  val bytes = ByteArray(length)
                  dataInput.readFully(bytes)
                  readPadding(length)
                  return String(bytes, StandardCharsets.UTF_8)
              }

              fun readFixedOpaque(length: Int): ByteArray {
                  val bytes = ByteArray(length)
                  dataInput.readFully(bytes)
                  readPadding(length)
                  return bytes
              }

              fun readVariableOpaque(): ByteArray {
                  val length = dataInput.readInt()
                  if (length < 0) throw IllegalArgumentException("Negative opaque length: \$length")
                  return readFixedOpaque(length)
              }

              private fun readPadding(length: Int) {
                  val remainder = length % 4
                  if (remainder != 0) {
                      val padding = 4 - remainder
                      dataInput.skipBytes(padding)
                  }
              }
          }
        KOTLIN

        out.close

        # Generate XdrWriter
        file_name = 'XdrWriter.kt'
        out = @output.open(file_name)

        out.puts <<~KOTLIN
          // Automatically generated by xdrgen
          // DO NOT EDIT or your changes may be overwritten

          package #{@package}

          import java.io.DataOutputStream
          import java.io.OutputStream
          import java.nio.charset.StandardCharsets

          /**
           * XDR writer for encoding data to XDR format.
           */
          class XdrWriter(output: OutputStream) {
              private val dataOutput = DataOutputStream(output)

              fun writeInt(value: Int) {
                  dataOutput.writeInt(value)
              }

              fun writeUnsignedInt(value: UInt) {
                  dataOutput.writeInt(value.toInt())
              }

              fun writeLong(value: Long) {
                  dataOutput.writeLong(value)
              }

              fun writeUnsignedLong(value: ULong) {
                  dataOutput.writeLong(value.toLong())
              }

              fun writeFloat(value: Float) {
                  dataOutput.writeFloat(value)
              }

              fun writeDouble(value: Double) {
                  dataOutput.writeDouble(value)
              }

              fun writeBoolean(value: Boolean) {
                  dataOutput.writeInt(if (value) 1 else 0)
              }

              fun writeString(value: String) {
                  val bytes = value.toByteArray(StandardCharsets.UTF_8)
                  dataOutput.writeInt(bytes.size)
                  dataOutput.write(bytes)
                  writePadding(bytes.size)
              }

              fun writeFixedOpaque(value: ByteArray, expectedLength: Int? = null) {
                  expectedLength?.let {
                      require(value.size == it) {
                          "Expected fixed opaque length \$it, got \${value.size}"
                      }
                  }
                  dataOutput.write(value)
                  writePadding(value.size)
              }

              fun writeVariableOpaque(value: ByteArray) {
                  dataOutput.writeInt(value.size)
                  dataOutput.write(value)
                  writePadding(value.size)
              }

              private fun writePadding(length: Int) {
                  val remainder = length % 4
                  if (remainder != 0) {
                      val padding = 4 - remainder
                      repeat(padding) { dataOutput.writeByte(0) }
                  }
              }

              fun flush() {
                  dataOutput.flush()
              }
          }
        KOTLIN

        out.close
      end

      def render_file_header(out)
        out.puts "// Automatically generated by xdrgen"
        out.puts "// DO NOT EDIT or your changes may be overwritten"
        out.puts
        out.puts "package #{@package}"
        out.puts
      end

      def render_source_comment(out, defn)
        return if defn.is_a?(AST::Definitions::Namespace)

        out.puts "/**"
        out.puts " * XDR Source:"
        defn.text_value.each_line do |line|
          out.puts " * #{line.rstrip}"
        end
        out.puts " */"
      end

      # Extract comments for a specific member from the source text
      # Returns array of comment lines (without // prefix) that precede the member
      def extract_member_comment(source_text, member_name)
        lines = source_text.split("\n")
        comments = []

        lines.each_with_index do |line, idx|
          # Check if this line contains the member declaration
          if line =~ /^\s*\S+\s+#{Regexp.escape(member_name)}\s*[=,;]/ || line =~ /^\s*#{Regexp.escape(member_name)}\s*[=,;]/
            # Check for inline comment on the same line
            if line =~ /\/\/(.*)$/
              comments << $1.strip
            end

            # Look backwards for preceding comments
            i = idx - 1
            while i >= 0
              prev_line = lines[i].strip
              # Stop if we hit a non-comment, non-blank line
              break if !prev_line.empty? && !prev_line.start_with?('//')
              # Collect comment lines
              if prev_line.start_with?('//')
                comment_text = prev_line.sub(/^\/\/\s*/, '')
                comments.unshift(comment_text)
              end
              i -= 1
            end
            break
          end
        end

        comments
      end

      # Extract comments for a union arm from the source text
      # Union arms have format: case DISCRIMINANT_VALUE: // comment
      # Returns array of comment lines
      def extract_union_arm_comment(source_text, arm)
        comments = []

        # Try to get case values from the arm
        return [] unless arm.respond_to?(:cases)

        arm.cases.each do |case_stmt|
          # Get the case text which includes inline comments
          case_text = case_stmt.text_value rescue nil
          next unless case_text

          # Extract inline comment from case line
          if case_text =~ /\/\/(.*)$/
            comment_text = $1.strip
            comments << comment_text unless comment_text.empty?
          end
        end

        # If no inline comments, check for preceding comments
        if comments.empty? && arm.cases.first
          first_case = arm.cases.first
          lines = source_text.split("\n")

          # Find the case line
          lines.each_with_index do |line, idx|
            # Simple heuristic: match the start of the case text
            case_start = first_case.text_value.split("\n").first.strip rescue nil
            if case_start && line.include?(case_start)
              # Look backwards for comments
              i = idx - 1
              while i >= 0
                prev_line = lines[i].strip
                break if !prev_line.empty? && !prev_line.start_with?('//')
                if prev_line.start_with?('//')
                  comment_text = prev_line.sub(/^\/\/\s*/, '')
                  comments.unshift(comment_text)
                end
                i -= 1
              end
              break
            end
          end
        end

        comments
      end

      # Render KDoc comment for a member (enum value, struct field, etc.)
      def render_member_comment(out, comments)
        return if comments.empty?

        if comments.length == 1
          out.puts "/** #{comments.first} */"
        else
          out.puts "/**"
          comments.each { |line| out.puts " * #{line}" }
          out.puts " */"
        end
      end

      def kotlin_type_for(decl)
        case decl
        when AST::Declarations::Void
          'Unit'
        when AST::Declarations::Optional
          "#{kotlin_type_for_typespec(decl.type)}?"
        when AST::Declarations::Array
          if decl.fixed?
            # Fixed arrays could be Array<T> or ByteArray for bytes
            inner_type = kotlin_type_for_typespec(decl.type)
            inner_type == 'Byte' ? 'ByteArray' : "Array<#{inner_type}>"
          else
            # Variable arrays become List
            inner_type = kotlin_type_for_typespec(decl.type)
            inner_type == 'Byte' ? 'ByteArray' : "List<#{inner_type}>"
          end
        else
          kotlin_type_for_typespec(decl.type)
        end
      end

      def kotlin_type_for_typespec(typespec)
        case typespec
        when AST::Typespecs::Int
          'Int'
        when AST::Typespecs::UnsignedInt
          'UInt'
        when AST::Typespecs::Hyper
          'Long'
        when AST::Typespecs::UnsignedHyper
          'ULong'
        when AST::Typespecs::Float
          'Float'
        when AST::Typespecs::Double
          'Double'
        when AST::Typespecs::Quadruple
          raise "Quadruple not supported in Kotlin"
        when AST::Typespecs::Bool
          'Boolean'
        when AST::Typespecs::String
          'String'
        when AST::Typespecs::Opaque
          'ByteArray'
        when AST::Typespecs::Simple
          name(typespec.resolved_type)
        else
          name(typespec)
        end
      end

      def decode_expression(decl, reader_var)
        case decl
        when AST::Declarations::Void
          # void
          ''
        when AST::Declarations::Optional
          inner_decode = decode_expression_for_typespec(decl.type, reader_var)
          "if (#{reader_var}.readBoolean()) #{inner_decode} else null"
        when AST::Declarations::Array
          if decl.fixed?
            _, size = decl.type.array_size
            inner_decode = decode_expression_for_typespec(decl.type, reader_var)

            if kotlin_type_for_typespec(decl.type) == 'Byte'
              "#{reader_var}.readFixedOpaque(#{size})"
            else
              "Array(#{size}) { #{inner_decode} }"
            end
          else
            inner_decode = decode_expression_for_typespec(decl.type, reader_var)

            if kotlin_type_for_typespec(decl.type) == 'Byte'
              "#{reader_var}.readVariableOpaque()"
            else
              "List(#{reader_var}.readInt()) { #{inner_decode} }"
            end
          end
        else
          decode_expression_for_typespec(decl.type, reader_var)
        end
      end

      def decode_expression_for_typespec(typespec, reader_var)
        case typespec
        when AST::Typespecs::Int
          "#{reader_var}.readInt()"
        when AST::Typespecs::UnsignedInt
          "#{reader_var}.readUnsignedInt()"
        when AST::Typespecs::Hyper
          "#{reader_var}.readLong()"
        when AST::Typespecs::UnsignedHyper
          "#{reader_var}.readUnsignedLong()"
        when AST::Typespecs::Float
          "#{reader_var}.readFloat()"
        when AST::Typespecs::Double
          "#{reader_var}.readDouble()"
        when AST::Typespecs::Bool
          "#{reader_var}.readBoolean()"
        when AST::Typespecs::String
          "#{reader_var}.readString()"
        when AST::Typespecs::Opaque
          if typespec.fixed?
            "#{reader_var}.readFixedOpaque(#{typespec.size})"
          else
            "#{reader_var}.readVariableOpaque()"
          end
        when AST::Typespecs::Simple
          type_name = name(typespec.resolved_type)
          "#{type_name}.decode(#{reader_var})"
        else
          type_name = name(typespec)
          "#{type_name}.decode(#{reader_var})"
        end
      end

      def encode_statement(decl, value_expr, writer_var, out)
        case decl
        when AST::Declarations::Void
          # Nothing to encode
        when AST::Declarations::Optional
          out.puts "if (#{value_expr} != null) {"
          out.indent do
            out.puts "#{writer_var}.writeBoolean(true)"
            encode_statement_for_typespec(decl.type, value_expr, writer_var, out)
          end
          out.puts "} else {"
          out.indent do
            out.puts "#{writer_var}.writeBoolean(false)"
          end
          out.puts "}"
        when AST::Declarations::Array
          if decl.fixed?
            if kotlin_type_for_typespec(decl.type) == 'Byte'
              _, size = decl.type.array_size
              out.puts "#{writer_var}.writeFixedOpaque(#{value_expr}, #{size})"
            else
              out.puts "#{value_expr}.forEach { item ->"
              out.indent do
                encode_statement_for_typespec(decl.type, 'item', writer_var, out)
              end
              out.puts "}"
            end
          else
            if kotlin_type_for_typespec(decl.type) == 'Byte'
              out.puts "#{writer_var}.writeVariableOpaque(#{value_expr})"
            else
              out.puts "#{writer_var}.writeInt(#{value_expr}.size)"
              out.puts "#{value_expr}.forEach { item ->"
              out.indent do
                encode_statement_for_typespec(decl.type, 'item', writer_var, out)
              end
              out.puts "}"
            end
          end
        else
          encode_statement_for_typespec(decl.type, value_expr, writer_var, out)
        end
      end

      def encode_statement_for_typespec(typespec, value_expr, writer_var, out)
        case typespec
        when AST::Typespecs::Int
          out.puts "#{writer_var}.writeInt(#{value_expr})"
        when AST::Typespecs::UnsignedInt
          out.puts "#{writer_var}.writeUnsignedInt(#{value_expr})"
        when AST::Typespecs::Hyper
          out.puts "#{writer_var}.writeLong(#{value_expr})"
        when AST::Typespecs::UnsignedHyper
          out.puts "#{writer_var}.writeUnsignedLong(#{value_expr})"
        when AST::Typespecs::Float
          out.puts "#{writer_var}.writeFloat(#{value_expr})"
        when AST::Typespecs::Double
          out.puts "#{writer_var}.writeDouble(#{value_expr})"
        when AST::Typespecs::Bool
          out.puts "#{writer_var}.writeBoolean(#{value_expr})"
        when AST::Typespecs::String
          out.puts "#{writer_var}.writeString(#{value_expr})"
        when AST::Typespecs::Opaque
          if typespec.fixed?
            out.puts "#{writer_var}.writeFixedOpaque(#{value_expr}, #{typespec.size})"
          else
            out.puts "#{writer_var}.writeVariableOpaque(#{value_expr})"
          end
        when AST::Typespecs::Simple
          out.puts "#{value_expr}.encode(#{writer_var})"
        else
          out.puts "#{value_expr}.encode(#{writer_var})"
        end
      end

      def arm_discriminant_value(arm, discriminant)
        # Handle default arm separately
        return 'else' if arm.is_a?(AST::Definitions::UnionDefaultArm)

        # Get the first case value for this arm
        first_case = arm.cases.first
        return 'else' unless first_case

        discriminant_type_name = kotlin_type_for(discriminant)

        if first_case.value.is_a?(AST::Identifier)
          # It's an enum value
          "#{discriminant_type_name}.#{first_case.value.name}"
        else
          # It's a numeric literal - need to wrap in value class constructor
          literal_value = first_case.value.value

          # Check if discriminant is a typedef (ends with Xdr suffix we add)
          if discriminant_type_name.end_with?('Xdr')
            # Wrap in value class constructor
            # Resolve to underlying type to determine literal suffix
            resolved_type = resolve_typedef_declaration(discriminant)
            wrapped_value = case resolved_type.type
            when AST::Typespecs::UnsignedInt
              "#{literal_value}u"
            when AST::Typespecs::UnsignedHyper
              "#{literal_value}uL"
            else
              literal_value.to_s
            end
            "#{discriminant_type_name}(#{wrapped_value})"
          else
            # Not a typedef, use raw literal
            literal_value.to_s
          end
        end
      end

      def simple_typedef?(decl)
        # Simple typedefs can use typealias
        case decl
        when AST::Declarations::Array, AST::Declarations::Optional
          false
        when AST::Declarations::Simple
          true
        else
          case decl.type
          when AST::Typespecs::Simple
            false # Reference types need wrappers
          else
            true # Primitive types can use typealias
          end
        end
      end

      def name(named)
        # Build the complete name path without Xdr suffixes, then add Xdr once at the end
        base_name = build_base_name(named)
        "#{base_name}Xdr"
      end

      def build_base_name(named)
        parent = build_base_name(named.parent_defn) if named.is_a?(AST::Concerns::NestedDefinition)
        result = named.name.camelize
        "#{parent}#{result}"
      end

      def escape_kotlin_keyword(name)
        # Kotlin keywords that need to be escaped with backticks
        kotlin_keywords = %w[val var fun class object interface when is in as break continue return this super if else while do for try catch finally throw typeof true false null]

        if kotlin_keywords.include?(name)
          "`#{name}`"
        else
          name
        end
      end

      def resolve_typedef_declaration(decl)
        # Resolve a declaration to its underlying type (following typedef chains)
        return decl unless decl.is_a?(AST::Declarations::Simple)

        # If it's a reference to another type, resolve it
        if decl.type.is_a?(AST::Typespecs::Simple)
          resolved_def = @top.find_definition(decl.type.text_value)
          if resolved_def.is_a?(AST::Definitions::Typedef)
            # Recursively resolve the typedef's declaration
            resolve_typedef_declaration(resolved_def.declaration)
          else
            decl
          end
        else
          decl
        end
      end

      def get_or_create_file(file_name)
        @output_files[file_name] ||= begin
          out = @output.open(file_name)
          out.puts "// Automatically generated by xdrgen"
          out.puts "// DO NOT EDIT or your changes may be overwritten"
          out.puts
          out.puts "package #{@package}"
          out.puts
          out
        end
      end
    end
  end
end